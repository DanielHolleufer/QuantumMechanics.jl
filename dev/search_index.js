var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumMechanics","category":"page"},{"location":"#QuantumMechanics","page":"Home","title":"QuantumMechanics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumMechanics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumMechanics]","category":"page"},{"location":"#QuantumMechanics.Bra","page":"Home","title":"QuantumMechanics.Bra","text":"Bra(b::Basis, data::AbstractVector{<:Number})\n\nCreate a bra in the basis b with vector representation given by data.\n\nIf the elements of data are not ComplexF64 they will beconverted to this type.\n\nFurthermore, the data field of a Bra is the adjoint of the data argiment\n\nExamples\n\njulia> Bra(FockBasis(4), [1, 0, 0, 0, 0])\nBra{FockBasis{Int64}}(FockBasis{Int64}((5,), 4, 0), ComplexF64[1.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im])\n\njulia> Bra(SpinBasis(1 // 2), [1/sqrt(2), im/sqrt(2)])\nBra{SpinBasis{1//2, Int64}}(SpinBasis{1//2, Int64}((2,), 1//2), ComplexF64[0.7071067811865475 + 0.0im 0.0 - 0.7071067811865475im])\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.Bra-Union{Tuple{B}, Tuple{B, LinearAlgebra.Adjoint{<:Number, <:AbstractVector{<:Number}}}} where B<:Basis","page":"Home","title":"QuantumMechanics.Bra","text":"Bra(b::Basis, data::Adjoint{<:Number,<:AbstractVector{<:Number}})\n\nCreate a bra in the basis b with vector representation given by data.\n\nIf the elements of data are not ComplexF64 they will beconverted to this type.\n\nHere data is already adjointed, and so will not be adjointed agian when constructing the Bra.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.CompositeBasis","page":"Home","title":"QuantumMechanics.CompositeBasis","text":"CompositeBasis(b::Basis...)\n\nCreate a basis for the composite system consisting of the systems corresponding to the given bases.\n\nIt is possible for a CompositeBasis to contain another CompositeBasis.\n\nExamples\n\njulia> composite_basis = CompositeBasis(GenericBasis(8), FockBasis(50, 20))\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20)), (8, 31))\n\njulia> CompositeBasis(composite_basis, SpinBasis(3//2))\nCompositeBasis{Tuple{CompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}, SpinBasis{3//2, Int64}}, Tuple{Int64, Int64}}((CompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20)), (8, 31)), SpinBasis{3//2, Int64}((4,), 3//2)), (248, 4))\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.FockBasis","page":"Home","title":"QuantumMechanics.FockBasis","text":"FockBasis(cutoff::Integer, offset::Integer=0)\n\nCreate a basis for the Fock space starting at the offset and ending at the cutoff.\n\nExamples\n\njulia> FockBasis(10)\nFockBasis{Int64}((11,), 10, 0)\n\njulia> FockBasis(10, 2)\nFockBasis{Int64}((9,), 10, 2)\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.GenericBasis","page":"Home","title":"QuantumMechanics.GenericBasis","text":"GenericBasis(d)\n\nCreate a generic basis with dimension d for a Hilbert space.\n\nExamples\n\njulia> GenericBasis(4)\nGenericBasis{Int64}((4,))\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.Ket","page":"Home","title":"QuantumMechanics.Ket","text":"Ket(b::Basis, data::AbstractVector{<:Number})\n\nCreate a ket in the basis b with vector representation given by data.\n\nIf the elements of data are not ComplexF64 they will beconverted to this type.\n\nExamples\n\njulia> Ket(FockBasis(4), [1, 0, 0, 0, 0])\nKet{FockBasis{Int64}}(FockBasis{Int64}((5,), 4, 0), ComplexF64[1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im])\n\njulia> Ket(SpinBasis(1 // 2), [1/sqrt(2), im/sqrt(2)])\nKet{SpinBasis{1//2, Int64}}(SpinBasis{1//2, Int64}((2,), 1//2), ComplexF64[0.7071067811865475 + 0.0im, 0.0 + 0.7071067811865475im])\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.Ket-Union{Tuple{B}, Tuple{B, LinearAlgebra.Adjoint{<:Number, <:AbstractVector{<:Number}}}} where B<:Basis","page":"Home","title":"QuantumMechanics.Ket","text":"Ket(b::Basis, data::Adjoint{<:Number,<:AbstractVector{<:Number}})\n\nCreate ket bra in the basis b with vector representation given by the adjointed of data.\n\nIf the elements of data are not ComplexF64 they will beconverted to this type.\n\nSince data is given as an adjointed vector, it will be adjointed again before when constructing the Ket, such that the data field will be a vector.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.SpinBasis","page":"Home","title":"QuantumMechanics.SpinBasis","text":"SpinBasis(spin)\n\nCreate a basis for a spin system with total spin equal to spin.\n\nThe argument spin must be integer or half integer. It is then stored as a Rational.\n\nExamples\n\njulia> SpinBasis(1 // 2)\nSpinBasis{1//2, Int64}((2,), 1//2)\n\njulia> SpinBasis(100)\nSpinBasis{100//1, Int64}((201,), 100//1)\n\n\n\n\n\n","category":"type"},{"location":"#Base.copy-Tuple{T} where T<:QuantumMechanics.StateVector","page":"Home","title":"Base.copy","text":"copy(ψ::StateVector)\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{Basis}","page":"Home","title":"Base.length","text":"length(b::Basis)\n\nReturn the total dimension of the Hilbert space spanned by the basis b.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Tuple{QuantumMechanics.StateVector}","page":"Home","title":"LinearAlgebra.norm","text":"norm(ψ::StateVector)\n\nCompute the norm of the state vector ψ.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize!-Tuple{QuantumMechanics.StateVector}","page":"Home","title":"LinearAlgebra.normalize!","text":"normalize!(ψ::StateVector)\n\nIn-place normalization of the state vector ψ.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize-Tuple{QuantumMechanics.StateVector}","page":"Home","title":"LinearAlgebra.normalize","text":"normalize(ψ::StateVector)\n\nNormalizes the state vector ψ.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.dagger-Tuple{Ket}","page":"Home","title":"QuantumMechanics.dagger","text":"dagger(ψ::StateVector)\n\nHermitian transpose of the state vector. Using dagger on a Ket or a Bra will respectively return a Bra or a Ket in the same basis as the input state, but whose data has been complex conjugated.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.flatten-Tuple{CompositeBasis}","page":"Home","title":"QuantumMechanics.flatten","text":"flatten(b::CompositeBasis)\n\nFlatten nested composite basis. Works recursively.\n\nExamples\n\njulia> flatten(CompositeBasis(CompositeBasis(FockBasis(1), FockBasis(2)), FockBasis(3)))\nCompositeBasis{Tuple{FockBasis{Int64}, FockBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64, Int64}}((FockBasis{Int64}((2,), 1, 0), FockBasis{Int64}((3,), 2, 0), FockBasis{Int64}((4,), 3, 0)), (2, 3, 4))\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.partialtrace-Tuple{CompositeBasis, Tuple{Vararg{Integer}}}","page":"Home","title":"QuantumMechanics.partialtrace","text":"partialtrace(b::CompositeBasis, indices...)\n\nRemove the bases with indices corresponding to the given indices from the composite bases b.\n\nIf the partial trace leaves multiple remaining bases, these will be return as a CompositeBasis. If only one basis remains after performing the partial trace, it will be returned as itself, i. e. not in a CompositeBasis.\n\nExamples\n\njulia> partialtrace(CompositeBasis(SpinBasis(1 // 2), FockBasis(10)), 2)\nSpinBasis{1//2, Int64}((2,), 1//2)\n\njulia> partialtrace(CompositeBasis(SpinBasis(1 // 2), SpinBasis(3 // 2), FockBasis(10)), 3)\nCompositeBasis{Tuple{SpinBasis{1//2, Int64}, SpinBasis{3//2, Int64}}, Tuple{Int64, Int64}}((SpinBasis{1//2, Int64}((2,), 1//2), SpinBasis{3//2, Int64}((4,), 3//2)), (2, 4))\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.tensor-Tuple{Basis}","page":"Home","title":"QuantumMechanics.tensor","text":"tensor(b::Basis...)\n\nCreate a basis for the composite system consisting of the systems corresponding to the given bases.\n\nWhen using tensor, rather than CompositeBasis, any CompositeBasis will be expanded into its components, meaning that the CompositeBasis returned from tensor will never contain another CompositeBasis.\n\nIt is also possible to use to otimes symbol ⊗ as an infix operator.\n\nRasing a basis b to the power of N, where N is a positive integer results in the tensor product of N copies of b.\n\nExamples\n\njulia> composite_basis = tensor(GenericBasis(8), FockBasis(50, 20))\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20)), (8, 31))\n\njulia> tensor(composite_basis, SpinBasis(3//2))\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}, SpinBasis{3//2, Int64}}, Tuple{Int64, Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20), SpinBasis{3//2, Int64}((4,), 3//2)), (8, 31, 4))\n\njulia> GenericBasis(12) ⊗ FockBasis(25) ⊗ SpinBasis(1)\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}, SpinBasis{1//1, Int64}}, Tuple{Int64, Int64, Int64}}((GenericBasis{Int64}((12,)), FockBasis{Int64}((26,), 25, 0), SpinBasis{1//1, Int64}((3,), 1//1)), (12, 26, 3))\n\njulia> GenericBasis(5)^4\nCompositeBasis{NTuple{4, GenericBasis{Int64}}, NTuple{4, Int64}}((GenericBasis{Int64}((5,)), GenericBasis{Int64}((5,)), GenericBasis{Int64}((5,)), GenericBasis{Int64}((5,))), (5, 5, 5, 5))\n\n\n\n\n\n","category":"method"}]
}
