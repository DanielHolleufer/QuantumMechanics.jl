var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuantumMechanics","category":"page"},{"location":"#QuantumMechanics","page":"Home","title":"QuantumMechanics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantumMechanics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QuantumMechanics]","category":"page"},{"location":"#QuantumMechanics.Bra","page":"Home","title":"QuantumMechanics.Bra","text":"Bra(b::Basis, data::AbstractArray{Number})\n\nCreate a bra in the basis b with vector representation given by data.\n\nThe vector representation is converted to a vector whose elements are complex floats. It also need not be normalized.\n\nExamples\n\njulia> Bra(FockBasis(4), [1, 0, 0, 0, 0])\nBra{FockBasis{Int64}, ComplexF64}(FockBasis{Int64}((5,), 4, 0), ComplexF64[1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im])\n\njulia> Bra(SpinBasis(1 // 2), [1/sqrt(2), im/sqrt(2)])\nBra{SpinBasis{1//2, Int64}, ComplexF64}(SpinBasis{1//2, Int64}((2,), 1//2), ComplexF64[0.7071067811865475 + 0.0im, 0.0 + 0.7071067811865475im])\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.CompositeBasis","page":"Home","title":"QuantumMechanics.CompositeBasis","text":"CompositeBasis(b::Basis...)\n\nCreate a basis for the composite system consisting of the systems corresponding to the given bases.\n\nIt is possible for a CompositeBasis to contain another CompositeBasis.\n\nExamples\n\njulia> composite_basis = CompositeBasis(GenericBasis(8), FockBasis(50, 20))\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20)), (8, 31))\n\njulia> CompositeBasis(composite_basis, SpinBasis(3//2))\nCompositeBasis{Tuple{CompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}, SpinBasis{3//2, Int64}}, Tuple{Int64, Int64}}((CompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20)), (8, 31)), SpinBasis{3//2, Int64}((4,), 3//2)), (248, 4))\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.FockBasis","page":"Home","title":"QuantumMechanics.FockBasis","text":"FockBasis(cutoff::Integer, offset::Integer=0)\n\nCreate a basis for the Fock space starting at the offset and ending at the cutoff.\n\nExamples\n\njulia> FockBasis(10)\nFockBasis{Int64}((11,), 10, 0)\n\njulia> FockBasis(10, 2)\nFockBasis{Int64}((9,), 10, 2)\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.GenericBasis","page":"Home","title":"QuantumMechanics.GenericBasis","text":"GenericBasis(d)\n\nCreate a generic basis with dimension d for a Hilbert space.\n\nExamples\n\njulia> GenericBasis(4)\nGenericBasis{Int64}((4,))\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.Ket","page":"Home","title":"QuantumMechanics.Ket","text":"Ket(b::Basis, data::AbstractArray{Number})\n\nCreate a ket in the basis b with vector representation given by data.\n\nThe vector representation is converted to a vector whose elements are complex floats. It also need not be normalized.\n\nExamples\n\njulia> Ket(FockBasis(4), [1, 0, 0, 0, 0])\nKet{FockBasis{Int64}, ComplexF64}(FockBasis{Int64}((5,), 4, 0), ComplexF64[1.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im, 0.0 + 0.0im])\n\njulia> Ket(SpinBasis(1 // 2), [1/sqrt(2), im/sqrt(2)])\nKet{SpinBasis{1//2, Int64}, ComplexF64}(SpinBasis{1//2, Int64}((2,), 1//2), ComplexF64[0.7071067811865475 + 0.0im, 0.0 + 0.7071067811865475im])\n\n\n\n\n\n","category":"type"},{"location":"#QuantumMechanics.SpinBasis","page":"Home","title":"QuantumMechanics.SpinBasis","text":"SpinBasis(spin)\n\nCreate a basis for a spin system with total spin equal to spin.\n\nThe argument spin must be integer or half integer. It is then stored as a Rational.\n\nExamples\n\njulia> SpinBasis(1 // 2)\nSpinBasis{1//2, Int64}((2,), 1//2)\n\njulia> SpinBasis(100)\nSpinBasis{100//1, Int64}((201,), 100//1)\n\n\n\n\n\n","category":"type"},{"location":"#Base.length-Tuple{Basis}","page":"Home","title":"Base.length","text":"length(b::Basis)\n\nReturn the total dimension of the Hilbert space spanned by the basis b.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.flatten-Tuple{CompositeBasis}","page":"Home","title":"QuantumMechanics.flatten","text":"flatten(b::CompositeBasis)\n\nFlatten nested composite basis. Works recursively.\n\nExamples\n\njulia> flatten(CompositeBasis(CompositeBasis(FockBasis(1), FockBasis(2)), FockBasis(3)))\nCompositeBasis{Tuple{FockBasis{Int64}, FockBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64, Int64}}((FockBasis{Int64}((2,), 1, 0), FockBasis{Int64}((3,), 2, 0), FockBasis{Int64}((4,), 3, 0)), (2, 3, 4))\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.partialtrace-Tuple{CompositeBasis, Tuple{Vararg{Integer}}}","page":"Home","title":"QuantumMechanics.partialtrace","text":"partialtrace(b::CompositeBasis, indices...)\n\nRemove the bases with indices corresponding to the given indices from the composite bases b.\n\nIf the partial trace leaves multiple remaining bases, these will be return as a CompositeBasis. If only one basis remains after performing the partial trace, it will be returned as itself, i. e. not in a CompositeBasis.\n\nExamples\n\njulia> partialtrace(CompositeBasis(SpinBasis(1 // 2), FockBasis(10)), 2)\nSpinBasis{1//2, Int64}((2,), 1//2)\n\njulia> partialtrace(CompositeBasis(SpinBasis(1 // 2), SpinBasis(3 // 2), FockBasis(10)), 3)\nCompositeBasis{Tuple{SpinBasis{1//2, Int64}, SpinBasis{3//2, Int64}}, Tuple{Int64, Int64}}((SpinBasis{1//2, Int64}((2,), 1//2), SpinBasis{3//2, Int64}((4,), 3//2)), (2, 4))\n\n\n\n\n\n","category":"method"},{"location":"#QuantumMechanics.tensor-Tuple{Basis}","page":"Home","title":"QuantumMechanics.tensor","text":"tensor(b::Basis...)\n\nCreate a basis for the composite system consisting of the systems corresponding to the given bases.\n\nWhen using tensor, rather than CompositeBasis, any CompositeBasis will be expanded into its components, meaning that the CompositeBasis returned from tensor will never contain another CompositeBasis.\n\nIt is also possible to use to otimes symbol ⊗ as an infix operator.\n\nRasing a basis b to the power of N, where N is a positive integer results in the tensor product of N copies of b.\n\nExamples\n\njulia> composite_basis = tensor(GenericBasis(8), FockBasis(50, 20))\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}}, Tuple{Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20)), (8, 31))\n\njulia> tensor(composite_basis, SpinBasis(3//2))\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}, SpinBasis{3//2, Int64}}, Tuple{Int64, Int64, Int64}}((GenericBasis{Int64}((8,)), FockBasis{Int64}((31,), 50, 20), SpinBasis{3//2, Int64}((4,), 3//2)), (8, 31, 4))\n\njulia> GenericBasis(12) ⊗ FockBasis(25) ⊗ SpinBasis(1)\nCompositeBasis{Tuple{GenericBasis{Int64}, FockBasis{Int64}, SpinBasis{1//1, Int64}}, Tuple{Int64, Int64, Int64}}((GenericBasis{Int64}((12,)), FockBasis{Int64}((26,), 25, 0), SpinBasis{1//1, Int64}((3,), 1//1)), (12, 26, 3))\n\njulia> GenericBasis(5)^4\nCompositeBasis{NTuple{4, GenericBasis{Int64}}, NTuple{4, Int64}}((GenericBasis{Int64}((5,)), GenericBasis{Int64}((5,)), GenericBasis{Int64}((5,)), GenericBasis{Int64}((5,))), (5, 5, 5, 5))\n\n\n\n\n\n","category":"method"}]
}
